===========================================
Guía de Recepción y Gestión en el Backend
Proyecto: Estación de Bicicletas
===========================================

-------------------------------------------
0) Objetivo
-------------------------------------------
Estandarizar cómo el backend (Node.js + Express + Cliente MQTT + MySQL)
debe suscribirse, validar, procesar y persistir los mensajes de los cerrojos,
así como cómo emitir comandos y correlacionar respuestas.

-------------------------------------------
1) Suscripciones (wildcards)
-------------------------------------------
El backend debe suscribirse a:
- stations/+/controller/+/locks/+/telemetry
- stations/+/controller/+/locks/+/event
- stations/+/controller/+/locks/+/state
- stations/+/controller/+/status
- stations/+/controller/+/config   (retained)

Notas:
- Al iniciar el servicio, leer inmediatamente los mensajes RETAINED
  de "config" y "status" para construir el estado inicial (inventario de
  locks por estación/controlador y su conectividad).
- Registrar en logs de nivel INFO la cantidad de dispositivos y locks
  detectados tras el arranque.

-------------------------------------------
2) Publicación de comandos (único tópico de salida)
-------------------------------------------
El backend SOLO publica comandos en:
- stations/{stationId}/controller/{deviceId}/locks/{lockId}/command/set

Ejemplo (abrir cerrojo):
{
  "ts": 1732473501123,
  "cmd": "unlock",      // "lock" | "unlock" | "reboot" | ...
  "reqId": "7c1b3c",    // correlación única por comando
  "timeoutMs": 5000
}

Expectativa:
- El dispositivo debe responder en .../state con el mismo reqId.
- Si no llega respuesta en "timeoutMs", marcar comando como "timeout".

-------------------------------------------
3) Parsing del tópico (router)
-------------------------------------------
Formato esperado (ejemplos):
- stations/{stationId}/controller/{deviceId}/locks/{lockId}/telemetry
- stations/{stationId}/controller/{deviceId}/locks/{lockId}/event
- stations/{stationId}/controller/{deviceId}/locks/{lockId}/state
- stations/{stationId}/controller/{deviceId}/status
- stations/{stationId}/controller/{deviceId}/config

Reglas:
- Extraer stationId, deviceId y lockId (cuando aplique) del TÓPICO,
  no del payload. El payload puede repetir estos campos, pero la
  verdad de enrutamiento es el TÓPICO.
- Validar que stationId/deviceId/lockId existan (según tópico).

-------------------------------------------
4) Validación de payload
-------------------------------------------
Validaciones mínimas por tipo:

A) telemetry:
- ts (number, ms UNIX) ✓
- state ("locked" | "unlocked") ✓
- battery (0-100) opcional pero recomendado
- rssi opcional
- fw opcional
- seq opcional (para idempotencia)
Acciones:
- Rechazar/ignorar si falta ts o state.
- Si trae seq, realizar DEDUP por (stationId, deviceId, lockId, seq).

B) event:
- ts ✓
- event (string) ✓
- details (obj) opcional
Acciones:
- Registrar SIEMPRE (auditoría).
- Clasificar severidad (info/warn/error) según catálogo.

C) state (ACK a comando):
- ts ✓
- reqId ✓ (debe existir en la tabla de comandos pendientes)
- result ("ok" | "error") ✓
- state ("locked" | "unlocked") opcional, si aplica
- error (string | null) opcional
Acciones:
- Correlacionar con comando por reqId → cerrar comando como success/fail.
- Persistir estado final del lock si viene “state”.

D) status (online/offline):
- { "status": "online" } retenido al conectar (desde $birth)
- { "status": "offline" } publicado por el LWT ($will)
Acciones:
- Actualizar la última conectividad del controller (deviceId).
- Propagar a locks asociados (opcional, depende del modelo).

E) config (retained):
- deviceId, stationId ✓
- lista de locks (lockId, position, etc.) ✓
Acciones:
- Upsert en catálogo de dispositivos y locks.
- Si faltan locks previos, marcarlos como “retirados” o “no reportados”.

-------------------------------------------
5) Persistencia (MySQL) – esquema mínimo sugerido
-------------------------------------------

Tabla stations
- id (PK)              VARCHAR
- name                 VARCHAR (opcional)
- created_at           DATETIME

Tabla controllers
- id (PK)              VARCHAR        -- deviceId
- station_id (FK)      VARCHAR
- fw                   VARCHAR
- hw                   VARCHAR
- last_status          ENUM('online','offline','unknown') DEFAULT 'unknown'
- last_seen_at         DATETIME NULL
- created_at           DATETIME

Tabla locks
- id (PK)              VARCHAR        -- lockId (único por controller)
- controller_id (FK)   VARCHAR
- position             VARCHAR NULL
- last_state           ENUM('locked','unlocked') NULL
- last_seq             BIGINT NULL
- last_battery         TINYINT NULL
- last_rssi            INT NULL
- updated_at           DATETIME
- created_at           DATETIME

Tabla telemetry
- id (PK)              BIGINT AUTO
- station_id           VARCHAR
- controller_id        VARCHAR
- lock_id              VARCHAR
- ts                   BIGINT         -- ms UNIX
- state                ENUM('locked','unlocked') NULL
- battery              TINYINT NULL
- rssi                 INT NULL
- fw                   VARCHAR NULL
- seq                  BIGINT NULL
- created_at           DATETIME

Índice recomendado: (station_id, controller_id, lock_id, ts)

Tabla events
- id (PK)              BIGINT AUTO
- station_id           VARCHAR
- controller_id        VARCHAR
- lock_id              VARCHAR
- ts                   BIGINT
- event                VARCHAR
- details_json         JSON NULL
- severity             ENUM('info','warn','error') DEFAULT 'info'
- created_at           DATETIME

Tabla commands
- id (PK)              BIGINT AUTO
- req_id               VARCHAR UNIQUE
- station_id           VARCHAR
- controller_id        VARCHAR
- lock_id              VARCHAR
- cmd                  VARCHAR
- ts_requested         BIGINT
- timeout_ms           INT
- status               ENUM('pending','success','error','timeout') DEFAULT 'pending'
- ts_resolved          BIGINT NULL
- error_msg            VARCHAR NULL
- created_at           DATETIME

-------------------------------------------
6) Flujo de comando (patrón request/response)
-------------------------------------------
1. API recibe intención (ej. POST /locks/{id}/unlock).
2. Backend genera reqId único (UUID corto) y publica comando en .../command/set.
3. Registra en tabla commands con status=pending.
4. Espera ACK en tópico .../state con mismo reqId:
   - Si llega "result=ok" antes de timeout → status=success.
   - Si "result=error" → status=error y guardar error_msg.
   - Si no llega antes de timeout → status=timeout.
5. API puede:
   - Responder inmediatamente con 202 Accepted y endpoint
     para consultar el estado por reqId.
   - O mantener long-poll/websocket para actualizar en vivo.

-------------------------------------------
7) Idempotencia y deduplicación
-------------------------------------------
- Si telemetry incluye "seq", mantener en "locks.last_seq" el último
  seq visto y descartar cualquier mensaje con seq ≤ last_seq.
- Para commands, "reqId" es UNIQUE. Ignorar duplicados en publish
  (si se reintenta) y en ACK (si llega dos veces).

-------------------------------------------
8) QoS, Retained y Clean Session
-------------------------------------------
- Telemetry y event → QoS 0 o 1 (según criticidad).
- command/set → QoS 1 recomendado.
- state (ACK) → QoS 1 recomendado.
- status y config → retained (siempre).
- Clean Session/Start del backend: TRUE (servicio stateless) o FALSE
  si se requiere exactamente-once con QoS≥1 y colas offline (opcional).
  Sugerencia: mantener el backend lo más stateless posible y apoyarse en DB.

-------------------------------------------
9) Seguridad (ACLs y autenticación)
-------------------------------------------
- Cada dispositivo (controller) AUTENTICA con usuario/contraseña o cert.
- ACL Mosquitto:
  - Dispositivo: solo PUBLISH en sus tópicos de telemetría/event/state/status/config;
    solo SUBSCRIBE a su propio .../command/#.
  - Backend: SUBSCRIBE global a topics de entrada; PUBLISH a .../command/set.
- Validar en backend que stationId/deviceId/lockId tengan relación válida
  antes de persistir.

-------------------------------------------
10) Observabilidad
-------------------------------------------
- Logs estructurados (JSON) con requestId, topic, type (telemetry/event/state/command),
  ids (stationId/deviceId/lockId), latencias y resultados.
- Métricas (Prometheus) mínimas:
  - mqtt_messages_received_total{type=...}
  - mqtt_commands_published_total{cmd=...}
  - mqtt_command_latency_ms_summary
  - device_status{status=online|offline}
  - db_write_failures_total
- Alertas:
  - Porcentaje de timeouts de comandos > UMBRAL.
  - Número de devices offline > UMBRAL.
  - Retraso en llegada de telemetry por device > UMBRAL.

-------------------------------------------
11) Manejo de arranque (bootstrap)
-------------------------------------------
- Al iniciar:
  1) Suscribirse a todos los tópicos.
  2) Leer "config" (retained) → upsert controllers/locks.
  3) Leer "status" (retained) → fijar online/offline.
  4) Opcional: enviar "get" (si existiera) para forzar publicación de estado.
- Registrar métricas de inventario: estaciones, controllers, locks activos.

-------------------------------------------
12) Manejo de errores y reintentos
-------------------------------------------
- Si payload JSON es inválido → log WARN + descartar (no persistir).
- Si falta "ts" o campos obligatorios → log WARN + descartar.
- Si DB falla → reintentar N veces (backoff). Si persiste, enviar a DLQ (cola
  de fallos) y alertar.
- Si ACK no llega en timeout → marcar comando timeout y notificar al cliente.

-------------------------------------------
13) Pseudocódigo (router de mensajes)
-------------------------------------------
onMqttMessage(topic, payload):
  parts = topic.split('/')
  // stations/{stationId}/controller/{deviceId}/...
  stationId  = parts[1]
  deviceId   = parts[3]
  section    = parts[4]     // 'locks' | 'status' | 'config'
  subtype    = parts[-1]    // 'telemetry' | 'event' | 'state' | 'status' | 'config'

  data = safeJsonParse(payload)
  if !data: log.warn("json_invalid", topic); return

  switch subtype:
    case 'telemetry':
      lockId = parts[6] (si section == 'locks')
      validateTelemetryOrDrop(data)
      dedupBySeqIfPresent(stationId, deviceId, lockId, data.seq)
      persistTelemetry(...)
      updateLockSnapshot(...)
    case 'event':
      lockId = parts[6]
      validateEventOrDrop(data)
      persistEvent(...)
    case 'state':
      lockId = parts[6]
      validateStateOrDrop(data)
      resolveCommandByReqId(data.reqId, data.result, data.state, data.error)
      updateLockSnapshotIfState(...)
    case 'status':
      validateStatusOrDrop(data)
      updateControllerStatus(deviceId, data.status)
    case 'config':
      validateConfigOrDrop(data)
      upsertControllerAndLocksFromConfig(data)

-------------------------------------------
14) Límites y saneamiento
-------------------------------------------
- Tamaño máximo de payload: 8-16 KB (definir política).
- Rechazar mensajes con timestamps demasiado en el futuro/pasado
  (ej. > 10 min desfasados) o normalizarlos con "received_at".
- Normalizar strings (trim, lowercase donde aplique).

-------------------------------------------
15) Tabla “chuletario” (resumen)
-------------------------------------------
Topic → Quién publica → Acción backend → Persistencia
- .../locks/+/telemetry → dispositivo → validar, dedup, snapshot → telemetry + locks
- .../locks/+/event     → dispositivo → auditar, clasificar → events
- .../locks/+/state     → dispositivo → resolver comando por reqId → commands (+locks)
- .../status            → dispositivo → conectividad controller → controllers
- .../config (retained) → dispositivo → inventario/upsert → controllers + locks
- .../command/set       → backend     → n/a (salida) → commands

-------------------------------------------
16) Decisiones de negocio relevantes
-------------------------------------------
- Los sensores/cerrojos NO conocen “bicicleta”.
- La asociación “bicicleta ↔ lock” se gestiona 100% en backend/DB.
- Cambiar una bicicleta de lock no requiere tocar firmware.

===========================================
FIN DE LA GUÍA
===========================================